# -*- coding: utf-8 -*-
"""a-starcode.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rgjEHTgWTHZvLT62FPNS_Eqdp-1ckyaP
"""

import heapq

class Task:
    def __init__(self, name, time_cost, dependencies=None):
        self.name = name
        self.time_cost = time_cost
        self.dependencies = dependencies if dependencies else []

# Example task definitions
tasks = {
    "Start": Task("Start", 0),
    "Literature Review": Task("Literature Review", 3, ["Start"]),
    "Research Proposal": Task("Research Proposal", 4, ["Literature Review"]),
    "Supervisor Feedback Round 1": Task("Supervisor Feedback Round 1", 2, ["Research Proposal"]),
    "Data Collection": Task("Data Collection", 6, ["Supervisor Feedback Round 1"]),
    "Data Cleaning": Task("Data Cleaning", 6, ["Research Proposal"]),
    "Draft Writing": Task("Draft Writing", 2, ["Literature Review"]),
    "Final Revision": Task("Final Revision", 4, ["Data Collection"]),
}

class State:
    def __init__(self, completed_tasks, total_cost, path):
        self.completed = set(completed_tasks)
        self.total_cost = total_cost
        self.path = path  # ordered list of task names

    def __lt__(self, other):
        return self.total_cost < other.total_cost

def heuristic(state):
    remaining = [t for t in tasks if t not in state.completed]
    return sum(tasks[t].time_cost for t in remaining if all(dep in state.completed for dep in tasks[t].dependencies))

def get_available_tasks(state):
    available = []
    for name, task in tasks.items():
        if name in state.completed:
            continue
        if all(dep in state.completed for dep in task.dependencies):
            available.append(task)
    return available

def a_star_thesis_planner():
    start_state = State(["Start"], 0, ["Start"])
    frontier = [(heuristic(start_state), start_state)]
    visited = set()

    while frontier:
        _, current = heapq.heappop(frontier)
        key = tuple(sorted(current.completed))
        if key in visited:
            continue
        visited.add(key)

        if len(current.completed) == len(tasks):
            return current.path, current.total_cost

        for task in get_available_tasks(current):
            new_completed = current.completed | {task.name}
            new_cost = current.total_cost + task.time_cost
            new_path = current.path + [task.name]
            new_state = State(new_completed, new_cost, new_path)
            f_score = new_cost + heuristic(new_state)
            heapq.heappush(frontier, (f_score, new_state))

    return None, float("inf")

if __name__ == "__main__":
    path, cost = a_star_thesis_planner()
    print("Optimal Task Order:")
    print(" â†’ ".join(path))
    print(f"Total Cost (Time Estimate): {cost}")